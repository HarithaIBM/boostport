diff --git a/include/boost/thread/detail/thread.hpp b/include/boost/thread/detail/thread.hpp
index 37173110..5274f08e 100644
--- a/include/boost/thread/detail/thread.hpp
+++ b/include/boost/thread/detail/thread.hpp
@@ -609,7 +609,12 @@ namespace boost
         hash_value(const thread::id &v)
         {
 #if defined BOOST_THREAD_PROVIDES_BASIC_THREAD_ID
+#ifndef __MVS__
           return hash_value(v.thread_data);
+#else
+          // treat thread_data (pthread_t) as if it's a uint64_t
+          return hash_value(*(uint64_t*)(&v.thread_data));
+#endif
 #else
           return hash_value(v.thread_data.get());
 #endif
@@ -642,11 +647,19 @@ namespace boost
     public:
         id() BOOST_NOEXCEPT:
 #if defined BOOST_THREAD_PROVIDES_BASIC_THREAD_ID
+#ifndef __MVS__
         thread_data(0)
+#else
+        // have to use memset() since pthread_t technically isn't a number on z/OS
+        thread_data() { memset (&thread_data, 0, sizeof(pthread_t)); }
+#endif
 #else
         thread_data()
 #endif
-        {}
+#ifndef __MVS__
+         {}
+#endif
+#ifndef __MVS__
 
         bool operator==(const id& y) const BOOST_NOEXCEPT
         {
@@ -677,6 +690,39 @@ namespace boost
         {
             return !(thread_data<y.thread_data);
         }
+#else
+        // treat thread_data (pthread_t) as if it's a uint64_t
+
+        bool operator==(const id& y) const BOOST_NOEXCEPT
+        {
+            return *(uint64_t*)(&thread_data)==*(uint64_t*)(&y.thread_data);
+        }
+
+        bool operator!=(const id& y) const BOOST_NOEXCEPT
+        {
+            return *(uint64_t*)(&thread_data)!=*(uint64_t*)(&y.thread_data);
+        }
+
+        bool operator<(const id& y) const BOOST_NOEXCEPT
+        {
+            return *(uint64_t*)(&thread_data)<*(uint64_t*)(&y.thread_data);
+        }
+
+        bool operator>(const id& y) const BOOST_NOEXCEPT
+        {
+            return *(uint64_t*)(&y.thread_data)<*(uint64_t*)(&thread_data);
+        }
+
+        bool operator<=(const id& y) const BOOST_NOEXCEPT
+        {
+            return !(*(uint64_t*)(&y.thread_data)<*(uint64_t*)(&thread_data));
+        }
+
+        bool operator>=(const id& y) const BOOST_NOEXCEPT
+        {
+            return !(*(uint64_t*)(&thread_data)<*(uint64_t*)(&y.thread_data));
+        }
+#endif
 
 #ifndef BOOST_NO_IOSTREAM
 #ifndef BOOST_NO_MEMBER_TEMPLATE_FRIENDS
@@ -685,7 +731,12 @@ namespace boost
   std::basic_ostream<charT, traits>&
         operator<<(std::basic_ostream<charT, traits>& os, const id& x)
         {
+#ifndef __MVS__
             if(x.thread_data)
+#else
+            // treat thread_data (pthread_t) as if it's a uint64_t
+            if((uint64_t*)(&x.thread_data))
+#endif
             {
                 io::ios_flags_saver  ifs( os );
                 return os<< std::hex << x.thread_data;
diff --git a/include/boost/thread/pthread/thread_data.hpp b/include/boost/thread/pthread/thread_data.hpp
index c43b276d..9c670683 100644
--- a/include/boost/thread/pthread/thread_data.hpp
+++ b/include/boost/thread/pthread/thread_data.hpp
@@ -146,7 +146,12 @@ namespace boost
             bool interrupt_requested;
 //#endif
             thread_data_base():
+#ifndef __MVS__
                 thread_handle(0),
+#else
+                // pthread_t isn't a number on z/OS
+                thread_handle(),
+#endif
                 done(false),join_started(false),joined(false),
                 thread_exit_callbacks(0),
 //#if defined BOOST_THREAD_PROVIDES_INTERRUPTIONS
@@ -161,7 +166,12 @@ namespace boost
                 , interrupt_enabled(true)
                 , interrupt_requested(false)
 //#endif
+#ifndef __MVS__
             {}
+#else
+            // need memset() since pthread_t isn't a number on z/OS
+            { memset(&thread_handle, 0, sizeof(pthread_t)); }
+#endif
             virtual ~thread_data_base();
 
             typedef pthread_t native_handle_type;
